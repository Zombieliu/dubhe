  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module constantinople::dapp_schema {

  use constantinople::dapp_metadata::DappMetadata;

  use dubhe::storage_value;

  use dubhe::storage_value::StorageValue;

  use dubhe::storage_migration;

  use sui::transfer::public_share_object;

  use dubhe::type_info;

  public struct Dapp has key, store {
    id: UID,
  }

  public fun borrow_admin(self: &Dapp): &StorageValue<address> {
    storage_migration::borrow_field(&self.id, b"admin")
  }

  public(package) fun borrow_mut_admin(self: &mut Dapp): &mut StorageValue<address> {
    storage_migration::borrow_mut_field(&mut self.id, b"admin")
  }

  public fun borrow_package_id(self: &Dapp): &StorageValue<address> {
    storage_migration::borrow_field(&self.id, b"package_id")
  }

  public(package) fun borrow_mut_package_id(self: &mut Dapp): &mut StorageValue<address> {
    storage_migration::borrow_mut_field(&mut self.id, b"package_id")
  }

  public fun borrow_version(self: &Dapp): &StorageValue<u32> {
    storage_migration::borrow_field(&self.id, b"version")
  }

  public(package) fun borrow_mut_version(self: &mut Dapp): &mut StorageValue<u32> {
    storage_migration::borrow_mut_field(&mut self.id, b"version")
  }

  public fun borrow_metadata(self: &Dapp): &StorageValue<DappMetadata> {
    storage_migration::borrow_field(&self.id, b"metadata")
  }

  public(package) fun borrow_mut_metadata(self: &mut Dapp): &mut StorageValue<DappMetadata> {
    storage_migration::borrow_mut_field(&mut self.id, b"metadata")
  }

  public fun borrow_schemas(self: &Dapp): &StorageValue<vector<address>> {
    storage_migration::borrow_field(&self.id, b"schemas")
  }

  public(package) fun borrow_mut_schemas(self: &mut Dapp): &mut StorageValue<vector<address>> {
    storage_migration::borrow_mut_field(&mut self.id, b"schemas")
  }

  public fun borrow_safe_mode(self: &Dapp): &StorageValue<bool> {
    storage_migration::borrow_field(&self.id, b"safe_mode")
  }

  public(package) fun borrow_mut_safe_mode(self: &mut Dapp): &mut StorageValue<bool> {
    storage_migration::borrow_mut_field(&mut self.id, b"safe_mode")
  }

  public(package) fun create(ctx: &mut TxContext): Dapp {
    let mut id = object::new(ctx);
    storage_migration::add_field<StorageValue<address>>(&mut id, b"admin", storage_value::new());
    storage_migration::add_field<StorageValue<address>>(&mut id, b"package_id", storage_value::new());
    storage_migration::add_field<StorageValue<u32>>(&mut id, b"version", storage_value::new());
    storage_migration::add_field<StorageValue<DappMetadata>>(&mut id, b"metadata", storage_value::new());
    storage_migration::add_field<StorageValue<vector<address>>>(&mut id, b"schemas", storage_value::new());
    storage_migration::add_field<StorageValue<bool>>(&mut id, b"safe_mode", storage_value::new());
    Dapp { id }
  }

  public(package) fun upgrade<DappKey: drop>(dapp: &mut Dapp, ctx: &TxContext) {
    assert!(dapp.borrow_metadata().contains(), 0);
    assert!(dapp.borrow_admin().get() == ctx.sender(), 0);
    let new_package_id = type_info::current_package_id<DappKey>();
    dapp.borrow_mut_package_id().set(new_package_id);
    dapp.borrow_mut_version().mutate!(|version| {
        *version = *version + 1;
        });
  }

  public(package) fun add_schema<Schema: key + store>(dapp: &mut Dapp, schema: Schema, ctx: &TxContext) {
    assert!(dapp.borrow_metadata().contains(), 0);
    assert!(dapp.borrow_admin().get() == ctx.sender(), 0);
    let schema_id = object::id_address(&schema);
    dapp.borrow_mut_schemas().borrow_mut().push_back(schema_id);
    public_share_object(schema);
  }

  #[test_only]

  public fun create_dapp_for_testing(ctx: &mut TxContext): Dapp {
    create(ctx)
  }

  #[test_only]

  public fun distroy_dapp_for_testing(dapp: Dapp) {
    let Dapp { id } = dapp;
    id.delete();
  }
}
