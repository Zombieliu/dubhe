  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module constantinople::entity_schema {

  use std::ascii::String;

  use std::ascii::string;

  use sui::package::UpgradeCap;

  use std::type_name;

  use dubhe::storage_migration;

  use dubhe::storage_value::{Self, StorageValue};

  use dubhe::storage_map::{Self, StorageMap};

  use dubhe::storage_double_map::{Self, StorageDoubleMap};

  use sui::dynamic_field as df;

  use sui::sui::SUI;

  use sui::coin::Coin;

  use sui::balance::Balance;

  use constantinople::monster_type::MonsterType;

  use constantinople::direction::Direction;

  use constantinople::terrain_type::TerrainType;

  use constantinople::monster_catch_result::MonsterCatchResult;

  use constantinople::map_config::MapConfig;

  use constantinople::position::Position;

  use constantinople::monster_info::MonsterInfo;

  public struct Entity has key, store {
    id: UID,
  }

  public fun borrow_player(self: &Entity): &StorageMap<address, bool> {
    storage_migration::borrow_field(&self.id, b"player")
  }

  public(package) fun player(self: &mut Entity): &mut StorageMap<address, bool> {
    storage_migration::borrow_mut_field(&mut self.id, b"player")
  }

  public fun borrow_monster(self: &Entity): &StorageMap<address, MonsterType> {
    storage_migration::borrow_field(&self.id, b"monster")
  }

  public(package) fun monster(self: &mut Entity): &mut StorageMap<address, MonsterType> {
    storage_migration::borrow_mut_field(&mut self.id, b"monster")
  }

  public fun borrow_obstruction(self: &Entity): &StorageMap<address, bool> {
    storage_migration::borrow_field(&self.id, b"obstruction")
  }

  public(package) fun obstruction(self: &mut Entity): &mut StorageMap<address, bool> {
    storage_migration::borrow_mut_field(&mut self.id, b"obstruction")
  }

  public fun borrow_owned_by(self: &Entity): &StorageMap<address, vector<address>> {
    storage_migration::borrow_field(&self.id, b"owned_by")
  }

  public(package) fun owned_by(self: &mut Entity): &mut StorageMap<address, vector<address>> {
    storage_migration::borrow_mut_field(&mut self.id, b"owned_by")
  }

  public fun borrow_encounterable(self: &Entity): &StorageMap<address, bool> {
    storage_migration::borrow_field(&self.id, b"encounterable")
  }

  public(package) fun encounterable(self: &mut Entity): &mut StorageMap<address, bool> {
    storage_migration::borrow_mut_field(&mut self.id, b"encounterable")
  }

  public fun borrow_moveable(self: &Entity): &StorageMap<address, bool> {
    storage_migration::borrow_field(&self.id, b"moveable")
  }

  public(package) fun moveable(self: &mut Entity): &mut StorageMap<address, bool> {
    storage_migration::borrow_mut_field(&mut self.id, b"moveable")
  }

  public(package) fun create(ctx: &mut TxContext): Entity {
    let mut id = object::new(ctx);
    storage_migration::add_field<StorageMap<address, bool>>(&mut id, b"player", storage_map::new());
    storage_migration::add_field<StorageMap<address, MonsterType>>(&mut id, b"monster", storage_map::new());
    storage_migration::add_field<StorageMap<address, bool>>(&mut id, b"obstruction", storage_map::new());
    storage_migration::add_field<StorageMap<address, vector<address>>>(&mut id, b"owned_by", storage_map::new());
    storage_migration::add_field<StorageMap<address, bool>>(&mut id, b"encounterable", storage_map::new());
    storage_migration::add_field<StorageMap<address, bool>>(&mut id, b"moveable", storage_map::new());
    Entity { id }
  }

  public fun migrate(_entity: &mut Entity, _cap: &UpgradeCap) {}

  // ======================================== View Functions ========================================

  public fun get_player(self: &Entity, key: address): &bool {
    self.borrow_player().borrow(key)
  }

  public fun get_player_keys(self: &Entity): vector<address> {
    self.borrow_player().keys()
  }

  public fun get_player_values(self: &Entity): vector<bool> {
    self.borrow_player().values()
  }

  public fun get_monster(self: &Entity, key: address): &MonsterType {
    self.borrow_monster().borrow(key)
  }

  public fun get_monster_keys(self: &Entity): vector<address> {
    self.borrow_monster().keys()
  }

  public fun get_monster_values(self: &Entity): vector<MonsterType> {
    self.borrow_monster().values()
  }

  public fun get_obstruction(self: &Entity, key: address): &bool {
    self.borrow_obstruction().borrow(key)
  }

  public fun get_obstruction_keys(self: &Entity): vector<address> {
    self.borrow_obstruction().keys()
  }

  public fun get_obstruction_values(self: &Entity): vector<bool> {
    self.borrow_obstruction().values()
  }

  public fun get_owned_by(self: &Entity, key: address): &vector<address> {
    self.borrow_owned_by().borrow(key)
  }

  public fun get_owned_by_keys(self: &Entity): vector<address> {
    self.borrow_owned_by().keys()
  }

  public fun get_owned_by_values(self: &Entity): vector<vector<address>> {
    self.borrow_owned_by().values()
  }

  public fun get_encounterable(self: &Entity, key: address): &bool {
    self.borrow_encounterable().borrow(key)
  }

  public fun get_encounterable_keys(self: &Entity): vector<address> {
    self.borrow_encounterable().keys()
  }

  public fun get_encounterable_values(self: &Entity): vector<bool> {
    self.borrow_encounterable().values()
  }

  public fun get_moveable(self: &Entity, key: address): &bool {
    self.borrow_moveable().borrow(key)
  }

  public fun get_moveable_keys(self: &Entity): vector<address> {
    self.borrow_moveable().keys()
  }

  public fun get_moveable_values(self: &Entity): vector<bool> {
    self.borrow_moveable().values()
  }

  // =========================================================================================================
}
